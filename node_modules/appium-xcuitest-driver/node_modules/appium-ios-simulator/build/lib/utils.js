"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.SIMULATOR_APP_NAME = exports.MOBILE_SAFARI_BUNDLE_ID = exports.SAFARI_STARTUP_TIMEOUT_MS = exports.activateApp = exports.getDeveloperRoot = exports.toBiometricDomainComponent = exports.getSimulatorInfo = exports.simExists = exports.killAllSimulators = void 0;
const logger_1 = __importDefault(require("./logger"));
const lodash_1 = __importDefault(require("lodash"));
const teen_process_1 = require("teen_process");
const asyncbox_1 = require("asyncbox");
const appium_xcode_1 = require("appium-xcode");
const path_1 = __importDefault(require("path"));
const device_utils_1 = require("./device-utils");
const DEFAULT_SIM_SHUTDOWN_TIMEOUT_MS = 30000;
const SAFARI_STARTUP_TIMEOUT_MS = 25 * 1000;
exports.SAFARI_STARTUP_TIMEOUT_MS = SAFARI_STARTUP_TIMEOUT_MS;
const MOBILE_SAFARI_BUNDLE_ID = 'com.apple.mobilesafari';
exports.MOBILE_SAFARI_BUNDLE_ID = MOBILE_SAFARI_BUNDLE_ID;
const SIMULATOR_APP_NAME = 'Simulator.app';
exports.SIMULATOR_APP_NAME = SIMULATOR_APP_NAME;
const APP_ACTIVATION_SCRIPT = (pid) => `
use framework "Foundation"
use framework "AppKit"
use scripting additions

set theApp to current application's NSRunningApplication's runningApplicationWithProcessIdentifier:${pid}
if theApp = null then
	log "Cannot find Simulator window under PID ${pid}. Is it running?"
	error number 1
end if
set result to theApp's activateWithOptions:3
if not result then
	log "Cannot activate Simulator window under PID ${pid}. Is it running?"
	error number 1
end if
`;
const BIOMETRICS = {
    touchId: 'fingerTouch',
    faceId: 'pearl',
};
/**
 * @param {string} name
 * @returns {string}
 */
function toBiometricDomainComponent(name) {
    if (!BIOMETRICS[name]) {
        throw new Error(`'${name}' is not a valid biometric. Use one of: ${JSON.stringify(lodash_1.default.keys(BIOMETRICS))}`);
    }
    return BIOMETRICS[name];
}
exports.toBiometricDomainComponent = toBiometricDomainComponent;
/**
 * @param {string} appName
 * @param {boolean} [forceKill=false]
 * @returns {Promise<number>}
 */
async function pkill(appName, forceKill = false) {
    let args = forceKill ? ['-9'] : [];
    args.push('-x', appName);
    try {
        await (0, teen_process_1.exec)('pkill', args);
        return 0;
    }
    catch (err) {
        // pgrep/pkill exit codes:
        // 0       One or more processes were matched.
        // 1       No processes were matched.
        // 2       Invalid options were specified on the command line.
        // 3       An internal error occurred.
        if (!lodash_1.default.isUndefined(err.code)) {
            throw new Error(`Cannot forcefully terminate ${appName}. pkill error code: ${err.code}`);
        }
        logger_1.default.error(`Received unexpected error while trying to kill ${appName}: ${err.message}`);
        throw err;
    }
}
/**
 * @param {number} [timeout=DEFAULT_SIM_SHUTDOWN_TIMEOUT_MS]
 * @returns {Promise<void>}
 */
async function killAllSimulators(timeout = DEFAULT_SIM_SHUTDOWN_TIMEOUT_MS) {
    logger_1.default.debug('Killing all iOS Simulators');
    const xcodeVersion = await (0, appium_xcode_1.getVersion)(true);
    if (lodash_1.default.isString(xcodeVersion)) {
        return;
    }
    const appName = path_1.default.parse(SIMULATOR_APP_NAME).name;
    // later versions are slower to close
    timeout = timeout * (xcodeVersion.major >= 8 ? 2 : 1);
    try {
        await (0, teen_process_1.exec)('xcrun', ['simctl', 'shutdown', xcodeVersion.major > 8 ? 'all' : 'booted'], { timeout });
    }
    catch (ign) { }
    const pids = [];
    try {
        const { stdout } = await (0, teen_process_1.exec)('pgrep', ['-f', `${appName}.app/Contents/MacOS/`]);
        if (stdout.trim()) {
            pids.push(...(stdout.trim().split(/\s+/)));
        }
    }
    catch (e) {
        if (e.code === 1) {
            logger_1.default.debug(`${appName} is not running. Continuing...`);
            return;
        }
        if (lodash_1.default.isEmpty(pids)) {
            logger_1.default.warn(`pgrep error ${e.code} while detecting whether ${appName} is running. Trying to kill anyway.`);
        }
    }
    if (!lodash_1.default.isEmpty(pids)) {
        logger_1.default.debug(`Killing processes: ${pids.join(', ')}`);
        try {
            await (0, teen_process_1.exec)('kill', ['-9', ...(pids.map((pid) => `${pid}`))]);
        }
        catch (ign) { }
    }
    logger_1.default.debug(`Using pkill to kill application: ${appName}`);
    try {
        await pkill(appName, true);
    }
    catch (ign) { }
    // wait for all the devices to be shutdown before Continuing
    // but only print out the failed ones when they are actually fully failed
    let remainingDevices = [];
    async function allSimsAreDown() {
        remainingDevices = [];
        let devices = await (0, device_utils_1.getDevices)();
        devices = lodash_1.default.flatten(lodash_1.default.values(devices));
        return lodash_1.default.every(devices, (sim) => {
            const state = sim.state.toLowerCase();
            const done = ['shutdown', 'unavailable', 'disconnected'].includes(state);
            if (!done) {
                remainingDevices.push(`${sim.name} (${sim.sdk}, udid: ${sim.udid}) is still in state '${state}'`);
            }
            return done;
        });
    }
    try {
        await (0, asyncbox_1.waitForCondition)(allSimsAreDown, {
            waitMs: timeout,
            intervalMs: 200
        });
    }
    catch (err) {
        if (remainingDevices.length > 0) {
            logger_1.default.warn(`The following devices are still not in the correct state after ${timeout} ms:`);
            for (let device of remainingDevices) {
                logger_1.default.warn(`    ${device}`);
            }
        }
        throw err;
    }
}
exports.killAllSimulators = killAllSimulators;
/**
 * @param {string} udid
 * @param {Record<string, any>} [opts={}]
 * @returns {Promise<any>}
 */
async function getSimulatorInfo(udid, opts = {}) {
    const { devicesSetPath } = opts;
    // see the README for github.com/appium/node-simctl for example output of getDevices()
    const devices = lodash_1.default.toPairs(await (0, device_utils_1.getDevices)({ devicesSetPath }))
        .map((pair) => pair[1])
        .reduce((a, b) => a.concat(b), []);
    return lodash_1.default.find(devices, (sim) => sim.udid === udid);
}
exports.getSimulatorInfo = getSimulatorInfo;
/**
 * @param {string} udid
 * @returns {Promise<boolean>}
 */
async function simExists(udid) {
    return !!(await getSimulatorInfo(udid));
}
exports.simExists = simExists;
/**
 * @returns {Promise<string>}
 */
async function getDeveloperRoot() {
    const { stdout } = await (0, teen_process_1.exec)('xcode-select', ['-p']);
    return stdout.trim();
}
exports.getDeveloperRoot = getDeveloperRoot;
/**
 * Activates the app having the given process identifier.
 * See https://developer.apple.com/documentation/appkit/nsrunningapplication/1528725-activatewithoptions?language=objc
 * for more details.
 *
 * @param {number|string} pid App process identifier
 * @throws {Error} If the given PID is not running or there was a failure
 * while activating the app
 */
async function activateApp(pid) {
    try {
        await (0, teen_process_1.exec)('osascript', ['-e', APP_ACTIVATION_SCRIPT(pid)]);
    }
    catch (e) {
        throw new Error(`Simulator window cannot be activated. Original error: ${e.stderr || e.message}`);
    }
}
exports.activateApp = activateApp;
//# sourceMappingURL=utils.js.map