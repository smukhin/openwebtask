"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const lodash_1 = __importDefault(require("lodash"));
const path_1 = __importDefault(require("path"));
const support_1 = require("@appium/support");
const logger_1 = __importDefault(require("../logger"));
const bluebird_1 = __importDefault(require("bluebird"));
const utils_1 = require("../utils");
// The root of all these files is located under Safari data container root
// in 'Library' subfolder
const DATA_FILES = [
    ['Caches', '*'],
    ['Image Cache', '*'],
    ['WebKit', utils_1.MOBILE_SAFARI_BUNDLE_ID, '*'],
    ['WebKit', 'GeolocationSites.plist'],
    ['WebKit', 'LocalStorage', '*.*'],
    ['Safari', '*'],
    ['Cookies', '*.binarycookies'],
    ['..', 'tmp', utils_1.MOBILE_SAFARI_BUNDLE_ID, '*'],
];
const extensions = {};
/**
 * Open the given URL in mobile Safari browser.
 * The browser will be started automatically if it is not running.
 *
 * @param {string} url - The URL to be opened.
 */
extensions.openUrl = async function openUrl(url) {
    if (!await this.isRunning()) {
        throw new Error(`Tried to open '${url}', but Simulator is not in Booted state`);
    }
    const timer = new support_1.timing.Timer().start();
    try {
        await this.launchApp(utils_1.MOBILE_SAFARI_BUNDLE_ID, {
            wait: true,
            timeoutMs: utils_1.SAFARI_STARTUP_TIMEOUT_MS,
        });
        await this.simctl.openUrl(url);
    }
    catch (err) {
        throw new Error(`Safari could not open '${url}' after ${timer.getDuration().asSeconds.toFixed(3)}s. ` +
            `Original error: ${err.stderr || err.message}`);
    }
    logger_1.default.debug(`Safari successfully opened '${url}' in ${timer.getDuration().asSeconds.toFixed(3)}s`);
};
/**
 * Clean up the directories for mobile Safari.
 * Safari will be terminated if it is running.
 *
 * @param {boolean} keepPrefs - Whether to keep Safari preferences from being deleted.
 */
extensions.scrubSafari = async function scrubSafari(keepPrefs = true) {
    try {
        await this.terminateApp(utils_1.MOBILE_SAFARI_BUNDLE_ID);
    }
    catch (ign) { }
    logger_1.default.debug('Scrubbing Safari data files');
    const safariData = await this.simctl.getAppContainer(utils_1.MOBILE_SAFARI_BUNDLE_ID, 'data');
    const libraryDir = path_1.default.resolve(safariData, 'Library');
    const deletePromises = DATA_FILES.map((p) => support_1.fs.rimraf(path_1.default.join(libraryDir, ...p)));
    if (!keepPrefs) {
        deletePromises.push(support_1.fs.rimraf(path_1.default.join(libraryDir, 'Preferences', '*.plist')));
    }
    await bluebird_1.default.all(deletePromises);
};
/**
 * Updates variious Safari settings. Simulator must be booted in order to for it
 * to success.
 *
 * @param {object} updates An object containing Safari settings to be updated.
 * The list of available setting names and their values could be retrived by
 * changing the corresponding Safari settings in the UI and then inspecting
 * 'Library/Preferences/com.apple.mobilesafari.plist' file inside of
 * com.apple.mobilesafari app container.
 * The full path to the Mobile Safari's container could be retrieved from
 * `xcrun simctl get_app_container <sim_udid> com.apple.mobilesafari data`
 * command output.
 * Use the `xcrun simctl spawn <sim_udid> defaults read <path_to_plist>` command
 * to print the plist content to the Terminal.
 */
extensions.updateSafariSettings = async function updateSafariSettings(updates) {
    if (lodash_1.default.isEmpty(updates)) {
        return false;
    }
    const containerRoot = await this.simctl.getAppContainer(utils_1.MOBILE_SAFARI_BUNDLE_ID, 'data');
    const plistPath = path_1.default.join(containerRoot, 'Library', 'Preferences', 'com.apple.mobilesafari.plist');
    return await this.updateSettings(plistPath, updates);
};
exports.default = extensions;
//# sourceMappingURL=safari.js.map