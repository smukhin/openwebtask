export default SimulatorXcode8;
declare class SimulatorXcode8 extends EventEmitter<[never]> {
    /**
     * Constructs the object with the `udid` and version of Xcode. Use the exported `getSimulator(udid)` method instead.
     *
     * @param {string} udid - The Simulator ID.
     * @param {import('appium-xcode').XcodeVersion} xcodeVersion - The target Xcode version in format {major, minor, build}.
     */
    constructor(udid: string, xcodeVersion: import('appium-xcode').XcodeVersion);
    /** @type {string|undefined|null} */
    _keychainsBackupPath: string | undefined | null;
    udid: string;
    simctl: any;
    xcodeVersion: import("appium-xcode").XcodeVersion;
    _platformVersion: any;
    keychainPath: string;
    _idb: any;
    _locationMenu: string;
    /**
     * @return {string} Bundle identifier of Simulator UI client.
     */
    get uiClientBundleId(): string;
    /**
     * Set the full path to the devices set. It is recommended to set this value
     * once right after Simulator instance is created and to not change it during
     * the instance lifecycle
     *
     * @param {?string} value The full path to the devices set root on the
     * local file system
     */
    set devicesSetPath(value: string | null);
    /**
     * @return {?string} The full path to the devices set where the current simulator is located.
     * `null` value means that the default path is used, which is usually `~/Library/Developer/CoreSimulator/Devices`
     */
    get devicesSetPath(): string | null;
    /**
     * Retrieves the current process id of the UI client
     *
     * @return {Promise<string|null>} The process ID or null if the UI client is not running
     */
    getUIClientPid(): Promise<string | null>;
    /**
     * Check the state of Simulator UI client.
     *
     * @return {Promise<boolean>} True of if UI client is running or false otherwise.
     */
    isUIClientRunning(): Promise<boolean>;
    /**
     * Get the platform version of the current Simulator.
     *
     * @return {Promise<string>} SDK version, for example '8.3'.
     */
    getPlatformVersion(): Promise<string>;
    /**
     * Retrieve the full path to the directory where Simulator stuff is located.
     *
     * @return {string} The path string.
     */
    getRootDir(): string;
    /**
     * Retrieve the full path to the directory where Simulator applications data is located.
     *
     * @return {string} The path string.
     */
    getDir(): string;
    /**
     * Retrieve the full path to the directory where Simulator logs are stored.
     *
     * @return {string} The path string.
     */
    getLogDir(): string;
    /**
     * Get the state and specifics of this sim.
     *
     * @return {Promise<Record<string, any>>} Simulator stats mapping, for example:
     * { name: 'iPhone 4s',
     *   udid: 'C09B34E5-7DCB-442E-B79C-AB6BC0357417',
     *   state: 'Shutdown',
     *   sdk: '8.3'
     * }
     */
    stat(): Promise<Record<string, any>>;
    /**
     * Check if the Simulator has been booted at least once
     * and has not been erased before
     *
     * @return {Promise<boolean>} True if the current Simulator has never been started before
     */
    isFresh(): Promise<boolean>;
    /**
     * Retrieves the state of the current Simulator. One should distinguish the
     * states of Simulator UI and the Simulator itself.
     *
     * @return {Promise<boolean>} True if the current Simulator is running.
     */
    isRunning(): Promise<boolean>;
    /**
     * Checks if the simulator is in shutdown state.
     * This method is necessary, because Simulator might also be
     * in the transitional Shutting Down state right after the `shutdown`
     * command has been issued.
     *
     * @return {Promise<boolean>} True if the current Simulator is shut down.
     */
    isShutdown(): Promise<boolean>;
    /**
     * @typedef {Object} SimulatorOptions
     * @property {?string} scaleFactor [null] - Defines the window scale value for the UI client window for the current Simulator.
     *   Equals to null by default, which keeps the current scale unchanged.
     *   It should be one of ['1.0', '0.75', '0.5', '0.33', '0.25'].
     * @property {number} startupTimeout [60000] - Number of milliseconds to wait until Simulator booting
     *   process is completed. The default timeout will be used if not set explicitly.
     */
    /**
     * Start the Simulator UI client with the given arguments
     * @param {Partial<SimulatorOptions>} opts - Simulator startup options
     */
    startUIClient(opts?: Partial<{
        /**
         * [null] - Defines the window scale value for the UI client window for the current Simulator.
         * Equals to null by default, which keeps the current scale unchanged.
         * It should be one of ['1.0', '0.75', '0.5', '0.33', '0.25'].
         */
        scaleFactor: string | null;
        /**
         * [60000] - Number of milliseconds to wait until Simulator booting
         * process is completed. The default timeout will be used if not set explicitly.
         */
        startupTimeout: number;
    }>): Promise<void>;
    /**
     * Executes given Simulator with options. The Simulator will not be restarted if
     * it is already running.
     *
     * @param {object} opts - One or more of available Simulator options.
     *   See {#startUIClient(opts)} documentation for more details on other supported keys.
     */
    run(opts?: object): Promise<void>;
    /**
     * Reset the current Simulator to the clean state.
     * It is expected the simulator is in shutdown state when this API is called.
     */
    clean(): Promise<void>;
    /**
     * @typedef {Object} ShutdownOptions
     * @property {?number|string} timeout The number of milliseconds to wait until
     * Simulator is shut down completely. No wait happens if the timeout value is not set
     */
    /**
     * Shut down the current Simulator.
     *
     * @param {Partial<ShutdownOptions>} opts
     * @throws {Error} If Simulator fails to transition into Shutdown state after
     * the given timeout
     */
    shutdown(opts?: Partial<{
        /**
         * The number of milliseconds to wait until
         * Simulator is shut down completely. No wait happens if the timeout value is not set
         */
        timeout: (number | string) | null;
    }>): Promise<void>;
    /**
     * Delete the particular Simulator from devices list
     */
    delete(): Promise<void>;
    /**
     * Activates Simulator window.
     *
     * @protected
     * @returns {Promise<string|null>} If the method returns a string then it should be a valid Apple Script which
     * is appended before each UI client command is executed. Otherwise the method should activate the window
     * itself and return nothing.
     */
    protected _activateWindow(): Promise<string | null>;
    /**
     * Execute given Apple Script inside a critical section, so other
     * sessions cannot influence the UI client at the same time.
     *
     * @param {string} appleScript - The valid Apple Script snippet to be executed.
     * @return {Promise<string>} The stdout output produced by the script.
     * @throws {Error} If osascript tool returns non-zero exit code.
     */
    executeUIClientScript(appleScript: string): Promise<string>;
    /**
     * @typedef {Object} ProcessInfo
     * @property {number} pid The actual process identifier.
     * Could be zero if the process is the system one.
     * @property {?string} group The process group identifier.
     * This could be `null` if the process is not a part of the
     * particular group. For `normal` application processes the group
     * name usually equals to `UIKitApplication`.
     * @property {string} name The process name, for example
     * `com.apple.Preferences`
     */
    /**
     * Lists processes that are currently running on the given Simulator.
     * The simulator must be in running state in order for this
     * method to work properly.
     *
     * @return {Promise<ProcessInfo[]>} The list of retrieved process
     * information
     * @throws {Error} if no process information could be retrieved.
     */
    ps(): Promise<{
        /**
         * The actual process identifier.
         * Could be zero if the process is the system one.
         */
        pid: number;
        /**
         * The process group identifier.
         * This could be `null` if the process is not a part of the
         * particular group. For `normal` application processes the group
         * name usually equals to `UIKitApplication`.
         */
        group: string | null;
        /**
         * The process name, for example
         * `com.apple.Preferences`
         */
        name: string;
    }[]>;
    /**
     * @return {Promise<string|null>} The full path to the simulator's WebInspector Unix Domain Socket
     *   or `null` if there is no socket.
     */
    getWebInspectorSocket(): Promise<string | null>;
    /**
     * IDB instance setter
     *
     * @param {any} value
     */
    set idb(value: Promise<any>);
    /**
     * @return {Promise<any>} idb instance
     */
    get idb(): Promise<any>;
    /**
     * @typedef {Object} KillOpts
     * @property {(number|string)?} pid - Process id of the UI Simulator window
     * @property {number|string} signal [2] - The signal number to send to the
     * `kill` command
     */
    /**
     * Kill the UI client if it is running.
     *
     * @param {Partial<KillOpts>} opts
     * @return {Promise<boolean>} True if the UI client was successfully killed or false
     *                   if it is not running.
     * @throws {Error} If sending the signal to the client process fails
     */
    killUIClient(opts?: Partial<{
        /**
         * - Process id of the UI Simulator window
         */
        pid: (number | string) | null;
        /**
         * [2] - The signal number to send to the
         * `kill` command
         */
        signal: number | string;
    }>): Promise<boolean>;
    /**
     * @return {number} The max number of milliseconds to wait until Simulator booting is completed.
     */
    get startupTimeout(): number;
    /**
     * Verify whether the Simulator booting is completed and/or wait for it
     * until the timeout expires.
     *
     * @param {number} startupTimeout - the number of milliseconds to wait until booting is completed.
     * @emits BOOT_COMPLETED_EVENT if the current Simulator is ready to accept simctl commands, like 'install'.
     */
    waitForBoot(startupTimeout: number): Promise<void>;
}
import { EventEmitter } from 'events';
//# sourceMappingURL=simulator-xcode-8.d.ts.map