"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.isolateAppBundle = exports.findApps = exports.isAppBundle = exports.parseLocalizableStrings = exports.verifyApplicationPlatform = exports.fetchSupportedAppPlatforms = exports.extractBundleVersion = exports.extractBundleId = exports.IPA_EXT = exports.APP_EXT = exports.SAFARI_BUNDLE_ID = void 0;
const lodash_1 = __importDefault(require("lodash"));
const path_1 = __importDefault(require("path"));
const support_1 = require("appium/support");
const logger_js_1 = __importDefault(require("./logger.js"));
const lru_cache_1 = require("lru-cache");
const node_os_1 = __importDefault(require("node:os"));
const teen_process_1 = require("teen_process");
const bluebird_1 = __importDefault(require("bluebird"));
const STRINGSDICT_RESOURCE = '.stringsdict';
const STRINGS_RESOURCE = '.strings';
exports.SAFARI_BUNDLE_ID = 'com.apple.mobilesafari';
exports.APP_EXT = '.app';
exports.IPA_EXT = '.ipa';
/** @type {LRUCache<string, import('@appium/types').StringRecord>} */
const PLIST_CACHE = new lru_cache_1.LRUCache({ max: 20 });
/**
 * Retrieves the value of the given entry name from the application's Info.plist.
 *
 * @this {Object} Optinal instance used for caching. Ususally the driver instance.
 * @param {string} app Full path to the app bundle root.
 * @param {string} entryName Key name in the plist.
 * @returns {Promise<any | undefined>} Either the extracted value or undefined if no such key has been found in the plist.
 * @throws {Error} If the application's Info.plist cannot be parsed.
 */
async function extractPlistEntry(app, entryName) {
    const plistPath = path_1.default.resolve(app, 'Info.plist');
    const parseFile = async () => {
        try {
            return await support_1.plist.parsePlistFile(plistPath);
        }
        catch (err) {
            throw new Error(`Could not extract Info.plist from '${path_1.default.basename(app)}': ${err.message}`);
        }
    };
    let plistObj = PLIST_CACHE.get(app);
    if (!plistObj) {
        plistObj = await parseFile();
        PLIST_CACHE.set(app, plistObj);
    }
    // @ts-ignore plistObj should be defined
    return plistObj[entryName];
}
/**
 *
 * @param {string} app
 * @returns {Promise<string>}
 */
async function extractBundleId(app) {
    const bundleId = await extractPlistEntry(app, 'CFBundleIdentifier');
    logger_js_1.default.debug(`Getting bundle ID from app '${app}': '${bundleId}'`);
    return bundleId;
}
exports.extractBundleId = extractBundleId;
/**
 *
 * @param {string} app
 * @returns {Promise<string>}
 */
async function extractBundleVersion(app) {
    return await extractPlistEntry(app, 'CFBundleVersion');
}
exports.extractBundleVersion = extractBundleVersion;
/**
 *
 * @param {string} app
 * @returns {Promise<string>}
 */
async function extractExecutableName(app) {
    return await extractPlistEntry(app, 'CFBundleExecutable');
}
/**
 *
 * @param {string} app
 * @returns {Promise<string[]>}
 */
async function fetchSupportedAppPlatforms(app) {
    try {
        const result = await extractPlistEntry(app, 'CFBundleSupportedPlatforms');
        if (!lodash_1.default.isArray(result)) {
            logger_js_1.default.warn(`${path_1.default.basename(app)}': CFBundleSupportedPlatforms is not a valid list`);
            return [];
        }
        return result;
    }
    catch (err) {
        logger_js_1.default.warn(`Cannot extract the list of supported platforms from '${path_1.default.basename(app)}': ${err.message}`);
        return [];
    }
}
exports.fetchSupportedAppPlatforms = fetchSupportedAppPlatforms;
/**
 * @typedef {Object} PlatformOpts
 *
 * @property {boolean} isSimulator - Whether the destination platform is a Simulator
 * @property {boolean} isTvOS - Whether the destination platform is a Simulator
 */
/**
 * Verify whether the given application is compatible to the
 * platform where it is going to be installed and tested.
 *
 * @param {string} app - The actual path to the application bundle
 * @param {PlatformOpts} expectedPlatform
 * @throws {Error} If bundle architecture does not match the expected device architecture.
 */
async function verifyApplicationPlatform(app, expectedPlatform) {
    logger_js_1.default.debug('Verifying application platform');
    const supportedPlatforms = await fetchSupportedAppPlatforms(app);
    logger_js_1.default.debug(`CFBundleSupportedPlatforms: ${JSON.stringify(supportedPlatforms)}`);
    const { isSimulator, isTvOS } = expectedPlatform;
    const prefix = isTvOS ? 'AppleTV' : 'iPhone';
    const suffix = isSimulator ? 'Simulator' : 'OS';
    const dstPlatform = `${prefix}${suffix}`;
    const appFileName = path_1.default.basename(app);
    if (!supportedPlatforms.includes(dstPlatform)) {
        throw new Error(`${isSimulator ? 'Simulator' : 'Real device'} architecture is not supported by the '${appFileName}' application. ` +
            `Make sure the correct deployment target has been selected for its compilation in Xcode.`);
    }
    if (isSimulator) {
        const executablePath = path_1.default.resolve(app, await extractExecutableName(app));
        const [resFile, resUname] = await bluebird_1.default.all([
            (0, teen_process_1.exec)('file', [executablePath]),
            (0, teen_process_1.exec)('uname', ['-m']),
        ]);
        const bundleExecutableInfo = lodash_1.default.trim(resFile.stdout);
        logger_js_1.default.debug(bundleExecutableInfo);
        const arch = lodash_1.default.trim(resUname.stdout);
        const isAppleSilicon = node_os_1.default.cpus()[0].model.includes('Apple');
        // We cannot run Simulator builds compiled for arm64 on Intel machines
        // Rosetta allows only to run Intel ones on arm64
        if (!lodash_1.default.includes(bundleExecutableInfo, `executable ${arch}`) &&
            !(isAppleSilicon && lodash_1.default.includes(bundleExecutableInfo, 'executable x86_64'))) {
            const bundleId = await extractBundleId(app);
            throw new Error(`The ${bundleId} application does not support the ${arch} Simulator ` +
                `architecture:\n${bundleExecutableInfo}\n\n` +
                `Please rebuild your application to support the ${arch} platform.`);
        }
    }
}
exports.verifyApplicationPlatform = verifyApplicationPlatform;
async function readResource(resourcePath) {
    const data = await support_1.plist.parsePlistFile(resourcePath);
    const result = {};
    for (const [key, value] of lodash_1.default.toPairs(data)) {
        result[key] = lodash_1.default.isString(value) ? value : JSON.stringify(value);
    }
    return result;
}
async function parseLocalizableStrings(opts) {
    const { app, language = 'en', localizableStringsDir, stringFile, strictMode } = opts;
    if (!app) {
        const message = `Strings extraction is not supported if 'app' capability is not set`;
        if (strictMode) {
            throw new Error(message);
        }
        logger_js_1.default.info(message);
        return {};
    }
    let lprojRoot;
    for (const subfolder of [`${language}.lproj`, localizableStringsDir, '']) {
        lprojRoot = path_1.default.resolve(app, subfolder);
        if (await support_1.fs.exists(lprojRoot)) {
            break;
        }
        const message = `No '${lprojRoot}' resources folder has been found`;
        if (strictMode) {
            throw new Error(message);
        }
        logger_js_1.default.debug(message);
    }
    logger_js_1.default.info(`Will extract resource strings from '${lprojRoot}'`);
    const resourcePaths = [];
    if (stringFile) {
        const dstPath = path_1.default.resolve(String(lprojRoot), stringFile);
        if (await support_1.fs.exists(dstPath)) {
            resourcePaths.push(dstPath);
        }
        else {
            const message = `No '${dstPath}' resource file has been found for '${app}'`;
            if (strictMode) {
                throw new Error(message);
            }
            logger_js_1.default.info(message);
            logger_js_1.default.info(`Getting all the available strings from '${lprojRoot}'`);
        }
    }
    if (lodash_1.default.isEmpty(resourcePaths) && (await support_1.fs.exists(String(lprojRoot)))) {
        const resourceFiles = (await support_1.fs.readdir(String(lprojRoot)))
            .filter((name) => lodash_1.default.some([STRINGS_RESOURCE, STRINGSDICT_RESOURCE], (x) => name.endsWith(x)))
            .map((name) => path_1.default.resolve(lprojRoot, name));
        resourcePaths.push(...resourceFiles);
    }
    logger_js_1.default.info(`Got ${resourcePaths.length} resource file(s) in '${lprojRoot}'`);
    if (lodash_1.default.isEmpty(resourcePaths)) {
        return {};
    }
    const resultStrings = {};
    const toAbsolutePath = function (p) {
        return path_1.default.isAbsolute(p) ? p : path_1.default.resolve(process.cwd(), p);
    };
    for (const resourcePath of resourcePaths) {
        if (!support_1.util.isSubPath(toAbsolutePath(resourcePath), toAbsolutePath(app))) {
            // security precaution
            throw new Error(`'${resourcePath}' is expected to be located under '${app}'`);
        }
        try {
            const data = await readResource(resourcePath);
            logger_js_1.default.debug(`Parsed ${lodash_1.default.keys(data).length} string(s) from '${resourcePath}'`);
            lodash_1.default.merge(resultStrings, data);
        }
        catch (e) {
            logger_js_1.default.warn(`Cannot parse '${resourcePath}' resource. Original error: ${e.message}`);
        }
    }
    logger_js_1.default.info(`Got ${lodash_1.default.keys(resultStrings).length} string(s) from '${lprojRoot}'`);
    return resultStrings;
}
exports.parseLocalizableStrings = parseLocalizableStrings;
/**
 * Check whether the given path on the file system points to the .app bundle root
 *
 * @param {string} appPath Possible .app bundle root
 * @returns {Promise<boolean>} Whether the given path points to an .app bundle
 */
async function isAppBundle(appPath) {
    return (lodash_1.default.endsWith(lodash_1.default.toLower(appPath), exports.APP_EXT) &&
        (await support_1.fs.stat(appPath)).isDirectory() &&
        (await support_1.fs.exists(path_1.default.join(appPath, 'Info.plist'))));
}
exports.isAppBundle = isAppBundle;
/**
 * Extract the given archive and looks for items with given extensions in it
 *
 * @param {string} archivePath Full path to a .zip archive
 * @param {Array<string>} appExtensions List of matching item extensions
 * @returns {Promise<[string, string[]]>} Tuple, where the first element points to
 * a temporary folder root where the archive has been extracted and the second item
 * contains a list of relative paths to matched items
 */
async function findApps(archivePath, appExtensions) {
    const useSystemUnzipEnv = process.env.APPIUM_PREFER_SYSTEM_UNZIP;
    const useSystemUnzip = lodash_1.default.isEmpty(useSystemUnzipEnv) || !['0', 'false'].includes(lodash_1.default.toLower(useSystemUnzipEnv));
    const tmpRoot = await support_1.tempDir.openDir();
    await support_1.zip.extractAllTo(archivePath, tmpRoot, { useSystemUnzip });
    const globPattern = `**/*.+(${appExtensions.map((ext) => ext.replace(/^\./, '')).join('|')})`;
    const sortedBundleItems = (await support_1.fs.glob(globPattern, {
        cwd: tmpRoot,
    })).sort((a, b) => a.split(path_1.default.sep).length - b.split(path_1.default.sep).length);
    return [tmpRoot, sortedBundleItems];
}
exports.findApps = findApps;
/**
 * Moves the application bundle to a newly created temporary folder
 *
 * @param {string} appRoot Full path to the .app bundle
 * @returns {Promise<string>} The new path to the app bundle.
 * The name of the app bundle remains though
 */
async function isolateAppBundle(appRoot) {
    const tmpRoot = await support_1.tempDir.openDir();
    const dstRoot = path_1.default.join(tmpRoot, path_1.default.basename(appRoot));
    await support_1.fs.mv(appRoot, dstRoot, { mkdirp: true });
    return dstRoot;
}
exports.isolateAppBundle = isolateAppBundle;
//# sourceMappingURL=app-utils.js.map